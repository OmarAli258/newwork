// Sys.vm

// Test Sys.min: Computes the minimum of two values (4 and 2)
function Sys.init 0
    push constant 4       // Push 4 onto the stack
    push constant 2       // Push 2 onto the stack
    call Sys.min 2        // Call Sys.min with 2 arguments
    // After calling Sys.min, 2 should be at the top of the stack

    // Return to HALT
    goto HALT

// Sys.min: Computes the minimum of two values on the stack
function Sys.min 0
    pop temp 0  // Pop the second value (arg2)
    pop temp 1  // Pop the first value (arg1)
    push temp 1 // Push arg1
    push temp 0 // Push arg2
    lt          // Compare arg1 < arg2
    if-goto LESSER
    push temp 0 // Push arg2 (arg2 is smaller)
    return
label LESSER
    push temp 1 // Push arg1 (arg1 is smaller)
    return

// Test Sys.max: Computes the maximum of two values (4 and 2)
function Sys.init 0
    push constant 4       // Push 4 onto the stack
    push constant 2       // Push 2 onto the stack
    call Sys.max 2        // Call Sys.max with 2 arguments
    // After calling Sys.max, 4 should be at the top of the stack

    // Return to HALT
    goto HALT

// Sys.max: Computes the maximum of two values on the stack
function Sys.max 0
    pop temp 0  // Pop the second value (arg2)
    pop temp 1  // Pop the first value (arg1)
    push temp 1 // Push arg1
    push temp 0 // Push arg2
    gt          // Compare arg1 > arg2
    if-goto GREATER
    push temp 0 // Push arg2 (arg2 is larger)
    return
label GREATER
    push temp 1 // Push arg1 (arg1 is larger)
    return

// Test Sys.range: Computes the range of the array [3, 7, 1, 9, 4]
function Sys.init 0
    push constant 2048    // Address of the array (starting address of static memory)
    push constant 5       // Number of elements in the array
    call Sys.range 2      // Call Sys.range with the array address and number of elements
    // After calling Sys.range, 8 should be at the top of the stack (9 - 1 = 8)

    // Return to HALT
    goto HALT

// Sys.range: Computes the range of values in the array
function Sys.range 2
    // Check if n <= 1
    push argument 1
    push constant 1
    lt
    if-goto RETURN_ZERO

    // Initialize min and max with the first element
    push argument 0
    pop pointer 1    // Set THAT to the address of the first element
    push that 0      // Push the first element onto the stack
    pop local 0      // local 0 = min = array[0]
    push that 0      // Push the first element onto the stack again
    pop local 1      // local 1 = max = array[0]

    // Loop through the array to find min and max
    push constant 1
    pop temp 0       // temp 0 = i = 1
label LOOP
    // Check if i >= n
    push temp 0
    push argument 1
    lt              // i < n
    if-goto END_LOOP

    // Load array[i]
    push argument 0
    push temp 0
    add
    pop pointer 1    // Set THAT to the address of array[i]
    push that 0      // Push array[i] onto the stack

    // Update min
    push local 0
    call Sys.min 2
    pop local 0

    // Update max
    push local 1
    call Sys.max 2
    pop local 1

    // Increment i
    push temp 0
    push constant 1
    add
    pop temp 0
    goto LOOP

label END_LOOP
    // Compute range = max - min
    push local 1
    push local 0
    sub
    return

label RETURN_ZERO
    push constant 0
    return

// HALT label: Infinite loop to stop the program
label HALT
    goto HALT
//// COMPUTE THE BITWISE EXCLUSIVE OR.
// This function takes two arguments and pushes the exclusive
// OR of its bits onto the stack. This function implements the
// formula:
//    x XOR y = (x AND (NOT y)) OR ((NOT x) and y)
// To call this function, you should:
//   1. push the two arguments onto the stack; and
//   2. call this function with call Sys.xor 2.
// Before returning, the function pushes the result onto the
// stack, so that, from the point of view of the callee, the
// result is at the top of the stack.
//
function Sys.xor 0
    // Your implementation goes here.
    push argument 1
    not
    push argument 0
    and
    push argument 0
    not
    push argument 1
    and
    add
    return

//// SHIFT A VALUE LEFT BY REPEATED ADDITION.
// This function takes two arguments and pushes the first argument
// shifted left by as many position as indicated by the second
// argument. To call this function, you should:
//   1. push the two arguments (number to be shifted and number of
//      shift positions) onto the stack; and
//   2. call this function with call Sys.shiftLeft 2.
// Before returning, the function pushes the result onto the
// stack, so that, from the point of view of the callee, the
// result is at the top of the stack.
//
function Sys.shiftLeft 2
    // Your implementation goes here.
    push argument 0
    pop local 0
label shiftleftloop
    push local 1
    push constant 1
    add
    pop local 1
    push argument 1
    push local 1
    lt
    if-goto end
    push local 0
    push local 0
    add
    pop local 0
    goto shiftleftloop
label end
    push local 0
    return

//// COMPUTE THE PARITY OF THE BOTTOM 15 BITS OF AN INTEGER.
// This function takes one arguments and pushes the parity of
// the fifteen right-most bits onto the stack. The possible output
// values are 1, if the number of 1s in the right-most fifteen
// bits is odd, or 0, if the number of 1s in the right-most
// fifteen bits is even. Here is some example output:
//
//     INPUT (binary)  | OUT |         NOTES
//    -----------------+-----+-----------------------
//    1000000000000000 |  0  | Left-most bit ignored.
//    0000000000000001 |  1  |
//    1000000000000001 |  1  | Left-most bit ignored.
//    0111111111011111 |  0  |
//    0111111111111111 |  1  |
//    1111111111111111 |  1  | Left-most bit ignored.
//
// To call this function, you should:
//   1. push the argument onto the stack; and
//   2. call this function with call Sys.computeParity 1.
// Before returning, the function pushes the result onto the
// stack, so that, from the point of view of the callee, the
// result is at the top of the stack.
//
function Sys.computeParity 2
    // Your implementation goes here.
    push constant 0
    pop local 0
label parityloop
    push constant 15
    push local 1
    eq
    if-goto end
    push constant 1
    push local 1
    call Sys.shiftLeft 2
    push argument 0
    and
    push constant 0
    eq
    if-goto nestedparityloop
    push local 0
    push constant 1
    call Sys.xor 2
    pop local 0
label nestedparityloop
    push local 1
    push constant 1
    add
    pop local 1
    goto parityloop
label end
    push local 0
    return


//// SET LEFT-MOST BIT TO PARITY BIT.
// This function takes one 16-bit string and pushes onto the stack
// the same bit string with the left-most bit set to the parity
// bit of the 15 right-most bits. Here is some example output:
//
//     INPUT (binary)  | OUTPUT (binary)  |         NOTES
//    -----------------+------------------+-----------------------
//    1000000000000000 | 0000000000000000 | Left-most bit ignored.
//    0000000000000001 | 1000000000000001 |
//    1000000000000001 | 1000000000000001 | Left-most bit ignored.
//    0111111111011111 | 0111111111011111 |
//    0111111111111111 | 1111111111111111 |
//    1111111111111111 | 1111111111111111 | Left-most bit ignored.
//
// To call this function, you should:
//   1. push the the argument onto the stack; and
//   2. call this function with call Sys.encode 1.
// Before returning, the function pushes the result onto the
// stack, so that, from the point of view of the callee, the
// result is at the top of the stack.
//
function Sys.encode 0
    // Your implementation goes here.
    push argument 0
    call Sys.computeParity 1
    push constant 1
    eq
    if-goto parity
    push constant 32767
    push argument 0
    and
    goto end
label parity
    push constant 32767
    neg
    push constant 1
    sub
    push argument 0
    or
label end
    return

// The emulator will start executing from here. You can modify
// the code below while testing and debugging your code, but
// please revert your changes before submitting to Gradescope;
// otherwise, your submission will most likely fail all tests.
//
// A better way to test your code is to use the supplied file
//   Sys.tst
// with the virtual machine emulator. Please do not submit this
// file to Gradescope, as this will cause your submission to be
// rejected.
//
function Sys.init 0
    call Sys.encode 1
label WHILE
    goto WHILE